\chapter{Quantum Computing}

\section{Learning Problems}

\subsection{A Motivating Example}


        Suppose you're involved in a simple card game: A dealer places two cards\footnote{Assume that the cards are
        either red or black, with equal probability of each occurring}  face down on a table. You win the game and a
        substantial prize if you can guess whether the two face-down cards share the same color. You're allowed to
        ask the dealer to reveal cards to you, but for each card revealed your potential prize gets smaller.

        How many of the cards do you need to see to determine with certainty whether the cards share the same
        color?  Maybe you don't need to know for certain. How does the probability of you being able to guess the
        correct answer relate to the number of cards seen?


        If you have no information at all, you can't do substantially better (or worse) than a fifty-percent
        chance. In fact, seeing only a single card, does not give you any more knowledge of what the answer to the
        question is. If you wanted to know with certainty what the answer was, you would need to see both cards.


        This is of course a very simple game, but it is an example of a type of problem that we refer to as
        \emph{learning problems} or often \emph{oracle problems}. These problems consist of a learner who is trying
        to determine the answer to some question, generally to find the output of a certain function. The learner
        starts out with incomplete information, but is given access to an \emph{oracle function} she can query to
        gain more information. An oracle function--also sometimes called a black-box function--is one that you can
        evaluate the oracle at any input of your choosing, but you have no information about the function other
        than its responses to your inputs. The learner's goal is to determine the answer to the question in as few
        questions as possible. 

        We rephrase the scenario given above in this language.  Choose 0 to represent a black card and 1 to
        represent a red card. Suppose the two facedown cards are labeled $a$ and $b$.   
       
        \begin{example} 
            Given oracle access to a function $f: \{a, b\} \rightarrow \{0, 1\}$. What is the minimum number of
            queries required to determine $f(a) \oplus f(b)$ where $\oplus$ denotes addition mod 2?
        \end{example}

        
        \TODO{rewrite this example}

        Phrasing problems in terms of oracles is an extremely useful tool. It provides an approach for using 
        information theoretic arguments to provide algorithmic lower bounds. We know of very few tools to show that 
        there is no way to possible solve something quickly.

        \begin{example}
            \TODO{Example 2?} 
        \end{example}


        

\section{Classical Computing}
        \subsection{History, Bits, Information Theory}
        Before we delve into  \emph{quantum computation}, we first briefly give an overview of the relevant 
        concepts from the study of \emph{classical} computation. Although we will not need information theory for 
        any of the arguments we will make, it will be used frequently as a source of intuition.

        The fundamental idea of information theory is that any the amount of information that an object contains is 
        determined exactly by the number of possible states it could have been in. In this way, the bit, which can 
        be in exactly one of two possible states is the most basic unit of information.


        In the 16th and 18th centuries mathematicians and logicians worked to convert formal systems of logic into 
        algebra and arithmetic. One of the most prominent successes of these attempts was by George Boole who 
        managed to faithfully encode propositional logic in the language of arithmetic and algebra. The idea was to 
        let 1 and 0 represent true and false respectively. Then, by interpreting addition and multiplication as mod 
        2, one obtains exactly the logical operations \texttt{AND} and  \texttt{XOR}. In modern terms, we recognize 
        this as the structure of the field $\F_2$. \TODO{remove this paragraph}
        
        \TODO{\textit{These next two paragraphs just repeat the previous two paragraphs, clean this up}}

        We define a bit as an element of $\Z/2\Z = \{0,1\}$. It also can be useful to think of bits as representing 
        a true or false value. This relationship gives a direct correspondence between classical computation and 
        propositional logic. We write the state space of a bit as $\Z/2\Z$ to emphasize that it has a natural 
        additive operation given by mod 2 addition.  Alluding to propositional logic, this operation is called 
        exclusive-or, usually written as \texttt{XOR} or $\oplus$, although we will oftentimes just write $+$.

        Of course having just one bit, is not particularly interesting. As a reference, it is common today to 
        measure memory in terms of \emph{gigabytes}. One gigabyte is equivalent to eight billion bits. We most 
        often work with \emph{strings of bits}. A string of 2 bits has four possible states, each described by an 
        element of $\Z/2\Z \times \Z/2\Z$. Analogously, an $n$ bit string has state space $(\Z/2\Z)^n$. The group 
        addition readily extends to $n$ bit strings giving it the operation that is commonly known as bitwise XOR.


        Thus any function $f :  \{0, 1\}^m \rightarrow \{0, 1\}^n$ can be expressed by some sequence of logical 
        operations and each sequence of logical operations corresponds to a function. 
        
        \subsection{Circuits and Logic Gates}

        \begin{definition}
            [Nielsen and Chuang, pg 129]
            A \emph{circuit} is made up of wires and gates, which carry information around, and perform simple 
            computational tasks, respectively.
        \end{definition}

        \begin{definition}
            [Nielsen and Chuang, pg 129]
            A \emph{logic gate} is a function $f : \{0, 1\}^k \rightarrow \{0, 1\}^\ell$ from some fixed number $k$ 
            of input bits to some fixed number $\ell$ of output bits.
        \end{definition}

        \begin{example}
         Here is an example of a logic gate

         \begin{figure}[ht]
            \centering
            \placeholderfig
            \caption{ The logic gates \texttt{AND} and \texttt{XOR} }
        \end{figure}
        \end{example}

        \bigskip

        \begin{example}
            Here is an example of a circuit

            \begin{figure}[ht]
                \centering
                    \placeholderfig
                \caption{An example of a basic circuit, maybe make it match whatever example I use for a circuit 
                family}
            \end{figure}

    
        \end{example}

        We state the following important result without proof.
        \begin{theorem}
            The set of gates $\{ \texttt{AND},\ \texttt{NOT},\ \texttt{OR} \}$ are \emph{universal}. That is any 
            function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ can be represented by circuit a consisting of only 
            \texttt{AND}, \texttt{NOT}, and \texttt{OR} gates.
        \end{theorem}
        
        %{\textcolor{red}{\bfseries I don't know how to fill the rest of this circuit part in}}
        

        \subsection{Circuits as Algorithms}
        
        \begin{definition}
            [verbatim from Sipser -- cleanup]
                 A \emph{circuit family} is an infinite list of circuits $(C_0, C_1, C_2, ...)$, where $C_n$ has 
                 $n$ input bits.
        \end{definition}

        \begin{definition}
            The circuit complexity of a function is the size complexity of a minimal circuit family for that 
            language. 
        \end{definition}

        \begin{example}
            Example circuit family to compute something. Maybe how many input bits are odd.  
            \begin{figure}[ht]
                \centering
                    \placeholderfig
                \caption{}
            \end{figure}
        \end{example}
        
        \subsection{Introduce controlled gate notation}
        
        Just example of Toffoli gate or whatever

        \subsection{Circuits with Oracles}

        We can consider circuits with oracle access.  Give example from original motivating problem.



\section{Quantum Computing}
        Now we introduce the concepts required for quantum computation. In the quantum world, the \emph{qubit} is 
        the fundamental unit of information. In the same way that we could express any classical algorithm as a 
        circuit of logical operations on bits, we can express any quantum operation as a sequence of \emph{unitary} 
        operations on \emph{qubits}.
       
   \subsection{Qubits}

        The following definitions will give a complete description of a model of quantum computing. These can all 
        be derived from the postulates of quantum mechanics.
        
      \begin{definition}
            Formally, a \emph{qubit} is unit vector in $\C^2$. That is a pair of complex numbers
            \[
                (\alpha, \beta) \in \C^2
            \]
            satisfying the normalization condition %
            \[
                |\alpha|^2 + |\beta|^2 = 1
            \]
            We consider the state space $\C^2$ to be equipped with the standard inner-product.
        \end{definition}
        
        It is very hard to picture qubits because they live on the unit sphere in $\C^2$. However, if we naively 
        think of them as vectors in $\R^2$ we can generate some limited geometric intuition. 
        
        \begin{figure}[ht]
            \centering
            \begin{center}
                \begin{tikzpicture}
                    \draw (2,2) circle (3cm);
                \end{tikzpicture}
            \end{center}
            \caption{An unfaithful depiction of a qubit (finish this diagram)}
        \end{figure}
        
    \subsection{Dirac Notation}

        There is a convention in quantum mechanics to write vectors representing quantum states using 
        \emph{bra-ket} notation. In this notation, row vectors are written with an angle bracket on the right, e.g.
        $\ket{\psi}$. While column vectors, are written with an angle bracket on the left e.g.
        $\bra{\psi}$.\footnote{In more generality, \emph{kets} $\ket{\, \cdot \,}$ denote vectors in the state 
        space, while \emph{bras} $\bra{\, \cdot \,}$ are elements of the dual space. For our purposes, considering 
    kets as row vectors and bras as column vectors will be sufficient.}

         %It is common in the field of quantum mechanics to write vectors representing quantum states in the form
        %$\ket{\psi}$. This `$\ket{\,\cdot \,}$' symbol is called the \emph{ket}.  Correspondingly, linear 
        %functionals on the state space are denoted $\bra{\psi}$. This symbol is called the \emph{bra}.

        %Together, they form a \emph{bra-ket} \TODO{Finish this}
       



        
        Although a qubit can exist in an uncountable number of states, paradoxically, they can only contain a 
        finite amount of classical information. This is because in order to extract \emph{classical} information 
        from a qubit, it must be \emph{measured}. 


    



        

        There are many interpretations of what measurement is and many deep philosophical questions, however it is 
        very clear from experimental evidence what outcomes it produces.
               
        

        \begin{postulate}
            Given a qubit $\ket{\phi} \in \C^{2}$, and any orthonormal basis $ \mathcal{B} = \{\ket{q_0}, \ket{q_1 
            }\}$ of $ \C^2$, we may perform a \emph{measurement} of $\psi$ with respect to the basis $\mathcal{B}$.  
            The result of this measurement is $\ket{q_0}$ with probability $\braket{q_0 | \phi }^2$ and $\ket{q_1}$ 
            with probability $\braket{q_0 | \phi }^2$.
        \end{postulate}
        
        This is only a specific case of a much more general postulate of quantum mechanics. In general, there are 
        more types of measurements that can be made and there are systems that are not finite dimensional.  However 
        , this restricted notion of measurement will be sufficient for the content of this thesis. A good 
        explanation of the postulates of quantum mechanics and how they relate to quantum computing can be found in 
        \cite{Nielsen&Chuang}.

        \begin{example}
            Given a qubit $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, a measurement of $\phi$ in the basis $\{ 
            \ket{0}, \ket{1}\}$ will return $\ket{0}$ with probability $ | \alpha |^2$  and $\ket{0}$ with 
            probability
            $ |\beta|^2 $.
        \end{example}

        
    
\subsection{Gates}

        While measurements can be made in any orthonormal basis, it is helpful to instead to choose a fixed basis 
        for measurement beforehand and instead allow for arbitrary change of basis operations on the state.  This 
        fixed basis is referred to as the \emph{computational basis}.  We assume that any measurement is made in 
        the computational basis unless explicitly noted otherwise.

        The valid operations on quantum states then, are the linear maps that map one orthonormal basis to another.  
        These are the isometries (inner-product preserving maps) of $\C^n$ which can be identified as $U(n)$, the 
        set of $n \times n$ \emph{unitary} matrices.

        \begin{definition}
            A matrix $U$ is said to be unitary if its conjugate transpose is equal to its inverse. That is often 
            written as $U^\dagger = U$.
        \end{definition}
        
        Quantum computation is the manipulation of qubits by these unitary matrices.

        \begin{definition}
            An $n$-qubit \emph{quantum gate} is a $2^n$ by $2^n$ unitary matrix.
        \end{definition}
        

        \begin{example}
            An important single qubit gate is the Hadamard gate defined by 
            \[
                H := \frac{1}{\sqrt{2}} \rmat{1}{1}{1}{-1}
            \]
            It has the nice property that it is it's own inverse, i.e. $H^2 = I$.

            The Hadamard sends
            \[
                \ket{0} = \rvec{1}{0}  \longmapsto \frac{1}{\sqrt{2}}\left(\ket{0} + \ket{1}\right)  = 
                \frac{1}{\sqrt{2}} \rvec{1}{1}
            \]
            and
            \[
                \ket{1} = \rvec{0}{1} \longmapsto \frac{1}{\sqrt{2}}\left( \ket{0} - \ket{1} \right) = 
                \frac{1}{\sqrt{2}} \rvec{1}{-1}
            \]
            %\TODO{Unit circle diagram}

        \end{example}
        
       %\TODO{Introduce Generators of U2?}

        %\TODO{Introduce other gates that we need}

        
        \subsection{(Possibly) Relevant Theorems about Quantum Circuits}

        \begin{theorem}
            No cloning? 
        \end{theorem}

        \begin{definition}
            idk
        \end{definition}

        \begin{theorem}
                Measurements can be made at the end
        \end{theorem}
        
        
\subsection{Quantum Circuits}


        Much like classical circuits, a quantum circuit is made up of wires and gates. 
        
        
        


        \begin{example}
            Deutsch-Josza
            $$
            \Qcircuit @C=1em @R=.7em {
                & \gate{H} & \gate{Z} & \gate{H} & \qw \\
                & \qw & \gate{X} & \qw & \qw
            }
            $$
        \end{example}

        The Deutsch-Josza Algorithm 
    
            \subsection{The Bernstein-Vazirani Algorithm}
            
            \begin{problem}
                Let $s \in \{0, 1\}^m$ be a hidden $m$-bit binary string and let $b \in \{0, 1\}$ be a hidden bit.  
                Given oracle access to a function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ defined by
                $f(\vec{x}) = \vec{x} \cdot \vec{s} + b \ (\text{mod } 2)$, how many queries are required to determine 
                the values of $\vec{s}$ and $b$?
            \end{problem}

            \textbf{The Bernstein Vazirani Algorithm}

            
            Define a circuit with state space $\C^{\otimes 2n} \otimes \C^2$. We initialize the system by setting 
            the first $n$ qubits to $\ket{1}$ and the response qubit to $\ket{0}$.

            The key to this problem will be to utilize a technique sometimes known as the \emph{phase-kickback 
            trick}. 
            
            
            \[
                \Qcircuit @C=1em @R=1em {
               \lstick{\ket{1}} & \qw &
               \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6.3em>&
                     \gate{H} & \qw &
                     \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6.5em>&
                    \ctrl{1} & \qw &
                    \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6em>&
                    \gate{H} & \qw &
                    \meter 
                    \\
                \lstick{\ket{1}} & \qw &\qw &
                    \gate{H} & \qw &\qw &
                    \ctrl{1} & \qw &\qw &
                    \gate{H} & \qw &
                    \meter 
                      \\
                \lstick{\ket{1}} & \qw &\qw &
                    \gate{H} & \qw &\qw &
                    \ctrl{1} & \qw &\qw &
                    \gate{H} & \qw &
                    \meter 
                      \\
                 \frac{1}{\sqrt{2}} &  \qw &\qw &
                     \qw &\qw &
                     \qw &                
                     \gate{U} & \qw &
                     \qw &  \qw &
                     \qw \frac{1}{\sqrt{2}} \\
               && 0 &  &  & 1 &  &  &2  & &
            }
           \]
           


        
