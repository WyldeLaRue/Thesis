\chapter{Quantum Computing}

\section{Learning Problems}

\subsection{A Motivating Example}


Suppose you're involved in a simple card game: A dealer places two cards (you can assume that the cards are
            either red or black, with equal probability of occurring)  face down on a table. You win the game and a
        substantial prize if you can guess whether the two face-down cards share the same color. You're allowed to
        ask the dealer to reveal cards to you, but for each card revealed your potential prize gets smaller.

        How many of the cards do you need to see to determine with certainty whether the cards share the same
        color?  Maybe you don't need to know for certain. How does the probability of you being able to guess the
        correct answer relate to the number of cards seen?


        If you have no information at all, you can't do substantially better (or worse) than a fifty-percent
        chance. In fact, seeing only a single card, does not give you any more knowledge of what the answer to the
        question is. If you wanted to know with certainty what the answer was, you would need to see both cards.


        This is of course a very simple game, but it is an example of a type of problem that we refer to as
        \emph{learning problems} or often \emph{oracle problems}. These problems consist of a learner who is trying
        to determine the answer to some question, generally to find the output of a certain function. The learner
        starts out with incomplete information, but is given access to an \emph{oracle function} she can query to
        gain more information. An oracle function--also sometimes called a black-box function--is one that you can
        evaluate the oracle at any input of your choosing, but you have no information about the function other
        than its responses to your inputs. The learner's goal is to determine the answer to the question in as few
        questions as possible. 

        We rephrase the scenario given above in this language.  Choose 0 to represent a black card and 1 to
        represent a red card. Suppose the two facedown cards are labeled $a$ and $b$.   
       
        \begin{example} 
            Given oracle access to a function $f: \{a, b\} \rightarrow \{0, 1\}$. What is the minimum number of
            queries required to determine $f(a) \oplus f(b)$ where $\oplus$ denotes addition mod 2?
        \end{example}

        For the reasons above, you can not do it fewer than two queries. We call the minimum number of queries you 
        need to make in order to solve the problem the \emph{query complexity} of the problem. In this case, the 
        query complexity is 2.
        %\TODO{rewrite this example}

        %Phrasing problems in terms of oracles is an extremely useful tool. It provides an approach for using 
        %information theoretic arguments to provide algorithmic lower bounds. We know of very few tools to show that 
        %there is no way to possible solve something quickly.

        %\begin{example}
            %\TODO{Example 2?} 
        %\end{example}


        

%\section{Classical Computing}
        %\subsection{History, Bits, Information Theory}
        %Before we delve into  \emph{quantum computation}, we first briefly give an overview of the relevant 
        %concepts from the study of \emph{classical} computation. Although we will not need information theory for 
        %any of the arguments we will make, it will be used frequently as a source of intuition.

        %The fundamental idea of information theory is that any the amount of information that an object contains is 
        %related to the number of possible states it could have been in. In this way, the bit, which can be in 
        %exactly one of two possible states is the most basic unit of information.


        %In the 16th and 18th centuries mathematicians and logicians worked to convert formal systems of logic into 
        %algebra and arithmetic. One of the most prominent successes of these attempts was by George Boole who 
        %managed to faithfully encode propositional logic in the language of arithmetic and algebra. The idea was to 
        %let 1 and 0 represent true and false respectively. Then, by interpreting addition and multiplication as mod 
        %2, one obtains exactly the logical operations \texttt{AND} and  \texttt{XOR}. In modern terms, we recognize 
        %this as the structure of the field $\F_2$. \TODO{remove this paragraph}
        
        %\TODO{\textit{These next two paragraphs just repeat the previous two paragraphs, clean this up}}

        %We define a bit as an element of $\Z/2\Z = \{0,1\}$. It also can be useful to think of bits as representing 
        %a true or false value. This relationship gives a direct correspondence between classical computation and 
        %propositional logic. We write the state space of a bit as $\Z/2\Z$ to emphasize that it has a natural 
        %additive operation given by mod 2 addition.  Alluding to propositional logic, this operation is called 
        %exclusive-or, usually written as \texttt{XOR} or $\oplus$, although we will oftentimes just write $+$.

        %Of course having just one bit, is not particularly interesting. As a reference, it is common today to 
        %measure memory in terms of \emph{gigabytes}. One gigabyte is equivalent to eight billion bits. We most 
        %often work with \emph{strings of bits}. A string of 2 bits has four possible states, each described by an 
        %element of $\Z/2\Z \times \Z/2\Z$. Analogously, an $n$ bit string has state space $(\Z/2\Z)^n$. The group 
        %addition readily extends to $n$ bit strings giving it the operation that is commonly known as bitwise XOR.


        %Thus any function $f :  \{0, 1\}^m \rightarrow \{0, 1\}^n$ can be expressed by some sequence of logical 
        %operations and each sequence of logical operations corresponds to a function. 
        
        %\subsection{Circuits and Logic Gates}

        %\begin{definition}
            %[Nielsen and Chuang, pg 129]
            %A \emph{circuit} is made up of wires and gates, which carry information around, and perform simple 
            %computational tasks, respectively.
        %\end{definition}

        %\begin{definition}
            %[Nielsen and Chuang, pg 129]
            %A \emph{logic gate} is a function $f : \{0, 1\}^k \rightarrow \{0, 1\}^\ell$ from some fixed number $k$ 
            %of input bits to some fixed number $\ell$ of output bits.
        %\end{definition}

        %\begin{example}
         %Here is an example of a logic gate

         %\begin{figure}[ht]
            %\centering
            %\placeholderfig
            %\caption{ The logic gates \texttt{AND} and \texttt{XOR} }
        %\end{figure}
        %\end{example}

        %\bigskip

        %\begin{example}
            %Here is an example of a circuit

            %\begin{figure}[ht]
                %\centering
                    %\placeholderfig
                %\caption{An example of a basic circuit, maybe make it match whatever example I use for a circuit 
                %family}
            %\end{figure}

    
        %\end{example}

        %We state the following important result without proof.
        %\begin{theorem}
            %The set of gates $\{ \texttt{AND},\ \texttt{NOT},\ \texttt{OR} \}$ are \emph{universal}. That is any 
            %function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ can be represented by circuit a consisting of only 
            %\texttt{AND}, \texttt{NOT}, and \texttt{OR} gates.
        %\end{theorem}
        
        %%{\textcolor{red}{\bfseries I don't know how to fill the rest of this circuit part in}}
        

        %\subsection{Circuits as Algorithms}
        
        %\begin{definition}
            %[verbatim from Sipser -- cleanup]
                 %A \emph{circuit family} is an infinite list of circuits $(C_0, C_1, C_2, ...)$, where $C_n$ has 
                 %$n$ input bits.
        %\end{definition}

        %\begin{definition}
            %The circuit complexity of a function is the size complexity of a minimal circuit family for that 
            %language. 
        %\end{definition}

        %\begin{example}
            %Example circuit family to compute something. Maybe how many input bits are odd.  
            %\begin{figure}[ht]
                %\centering
                    %\placeholderfig
                %\caption{}
            %\end{figure}
        %\end{example}
        
        %\subsection{Introduce controlled gate notation}
        
        %Just example of Toffoli gate or whatever

        %\subsection{Circuits with Oracles}

        %We can consider circuits with oracle access.  Give example from original motivating problem.



\section{Quantum Computing}
        Now we introduce the concepts required for quantum computation. In the quantum world, the \emph{qubit} is 
        the fundamental unit of information. In the same way that we can express any classical algorithm as a 
        circuit of logical operations on bits, we can express any quantum operation as a sequence of \emph{unitary} 
        operations on \emph{qubits}.
       
   \subsection{Qubits}

   The following treatment of quantum computing is largely taken from Nielsen and Chuang \cite{Nielsen&Chuang} and 
   Nielsen's more recent article \cite{QC}.  The goal of this chapter is to introduce a minimal model of quantum 
   computing that is sufficient for the tasks we will need in chapters 2 and 3. It can be hard to follow quantum 
   computing if one is not already familiar with it as there is a lot of notation and formal definitions. Moreover, 
   since quantum mechanics has a reputation for being unintuitive, it is often hard to feel like the intuitions one 
   has are correct.  However, I think that quantum circuits do a very good job of capturing the intuition from 
   classical computing and so I have tried to include many simple examples of circuits. For a very detailed and 
   gentle introduction to the subject, I strongly recommend reading the article \cite{QC}. For a much more 
   expansive view of the entire subject of quantum computing and topics not covered here, I would refer to Nielsen 
   and Chuang's text \cite{Nielsen&Chuang}.  
        
        Whereas the state of a bit has \emph{two} possible values---either 0 or 1---the state of a qubit is a unit
        vector in complex vector space spanned by \emph{two} basis states. We give the following precise definition
        \begin{definition}
            The state of a \emph{qubit} is a unit vector in $\C^2$. That is, a pair of complex numbers
            \[
                (\alpha, \beta) \in \C^2
            \]
            satisfying the normalization condition %
            \[
                |\alpha|^2 + |\beta|^2 = 1
            \]
        \end{definition}
        
        We refer to the space $\C^2$ as the \emph{state space} of a qubit and consider it to be an inner product 
        space equipped with the standard inner product on $\C^n$.\footnote{In quantum mechanics literature, state 
            spaces of quantum systems are always referred to as \emph{Hilbert spaces} regardless of their 
            dimension. This can be confusing as \emph{Hilbert spaces} in mathematics are generally associated with 
            infinite dimensional spaces. Since all of the spaces in this thesis will be finite dimensional (and 
        isomorphic to $\C^{2^n}$), it is easier to avoid the confusion and use the term state space instead.} 
        Recall the inner product of two vectors $x,y\in \C^n$ is given by
        \[
            \langle x, y \rangle = x_1\overline{y_1} + x_2\overline{y_2} + ... + x_n \overline{y_n} = \sum_{i=1}^n 
            x_i\overline{y_i}
       \]
       where $\overline{(\ )}$ denotes complex conjugation.

    We choose the standard basis $\{(0,1), (1,0)\}$ to represent $\C$. In order to make the analogy with bits more 
    clear, we denote            
    
    \[
            \ket{0} := \rvec{1}{0}, \quad
            \ket{1} := \rvec{0}{1}.
         \]
         The symbol $\ket{\ }$ is called a \emph{ket} and is used to denote a vector representing a quantum state.  
         It comes from the \emph{bra-ket} notation which is widely used in the greater theory of quantum mechanics.
        
        
         \subsection{Measurement} 
         
         Although a qubit has a quantum state in $\C^2$, the we cannot directly observe this quantum state. Despite 
         having what seems like a much richer state, when we try to measure qubits using any sort of detector, they 
         snap into the states $\ket{0}$ or $\ket{1}$. This of course defies any reasonable expectations one would 
         have about the world, and has raised much philosophical debate about how it should be interpreted. 
         However, regardless of what interpretation we take, it remains an experimental fact. The following 
         postulate formalizes this concept as a process called \emph{measurement in the computational basis}.

         \begin{postulate}
             Given a qubit $\psi$, we may perform \emph{measurement} of $\psi$ in the \emph{computational basis}. 
             If $\psi$ was in state $\alpha \ket{0} + \beta \ket{1}$ prior to the measurement, after the 
             measurement it will be in state $\ket{0}$ with probability $|\alpha|^2$ and $ \ket{1}$ with 
             probability $|\beta|^2.$
     \end{postulate}

        This is only a specific case of a much more general postulate of measurement in quantum mechanics. However, 
        this conception of measurement will be sufficient enough for many of the results in quantum computing and 
        all of the results that we will need to consider. A more in depth discussion of the postulates of quantum 
        mechanics and how they relate to quantum computing can be found in \cite{Nielsen&Chuang}.
        
        If we naively think of the state of a qubit as being in $\R^2$ rather than $\C^2$ by just ignoring the 
        imaginary part, we can generate some limited geometric intuition about what is going on.


        \begin{figure}[ht]
            \centering
            \begin{center}
            \begin{tikzpicture}
                 \draw[->] (0,0) -- (0,4) node[above]{$\ket{1}$};
                 \draw[->] (0,0) -- (4,0) node[right]{$\ket{0}$};
                 \draw[->, thick] (0,0) -- (2, 3.4) node[right]{$\frac{\sqrt{3}}{2}\ket{1} + \frac{1}{2}\ket{0}$};
            \end{tikzpicture}
            \end{center}
            \caption{A qubit with state $\frac{\sqrt{3}}{2}\ket{1} + \frac{1}{2}\ket{0}$ pictured in the plane by 
            ignoring the imaginary part. }
            \label{qubit-depiction}
    \end{figure}

    A measurement on the qubit pictured in Figure \ref{qubit-depiction} will return 0 with probability $3/4$ and 
    $1$ with probability $1/4$.  This perspective gives some justification for why the state of a qubit must be a 
    unit vector.  When written in the standard basis, the coefficients of $\ket{0}$ and $\ket{1}$ correspond to the 
    probability of a measurement producing that outcome. Thus requiring that this state be a unit vector is 
    equivalent to requiring that the total probabilities sum to one.


    This also motivates the final postulate of quantum mechanics that we will need to formalize this model of 
    quantum computation. 

    \begin{postulate}
        The valid operations on quantum states are those given by \emph{unitary transformations}.
    \end{postulate}
    
    The unitary transformations on $\C^n$ are exactly the \emph{isometries} of $\C^n$ that are linear. A linear map 
    $U : \C^n \rightarrow \C^n$ is said to be an isometry if $\| Uv \| = \|v\|$ for every vector $v \in \C^n$, in 
    other words, if it preserves the length of each vector.  This is, perhaps not too surprising, given that 
    preserving the length of each vector is necessary condition to ensure that the probabilities sum to one. 
    
    Unitary maps can also be defined algebraically. The following definition is probably the most commonly given 
    one for a unitary map.
    \begin{definition}
        A matrix $U : \C^n \rightarrow \C^n$ is said to be \emph{unitary} if it satisfies the identity $U^{-1} = 
        U^\dagger$ where $U^\dagger$ denotes the conjugate-transpose of $U$.
    \end{definition}

    
    
    
\subsection{Gates}
        
        By Postulate 2, the valid operations on a qubit are the $2 \times 2$ unitary matrices.

        This part of quantum computing can be confusing at first, since the notation constantly switches between 
        kets and matrices. For this reason, we have tried to write the examples clearly using each notation.

        \begin{example}
            The quantum \texttt{NOT} gate is the single qubit gate defined by
            \begin{align*}
                \ket{0} &\mapsto \ket{1} \\
                \ket{1} &\mapsto \ket{0}
            \end{align*}
            It should be noted that it is common to refer to the quantum \texttt{NOT} gate by the letter $X$.

            In standard vector notation this is
            \begin{align*}
                \rvec{1}{0} &\mapsto \rvec{0}{1} \\
                \rvec{0}{1} &\mapsto \rvec{1}{0} 
            \end{align*}

            Which gives us that the quantum \texttt{NOT} gate is represented by the matrix
            \[
                X := \rmat{0}{1}{1}{0}
            \]
        \end{example}

        
        \begin{example}
            A very important single qubit gate is the \emph{Hadamard} gate. The Hadamard gate, denoted $H$, can be 
            defined in terms of its action on the standard basis as
            \begin{align*}
                \ket{0} &\mapsto \frac{1}{\sqrt{2}}\left(\ket{0} + \ket{1}\right) \\
                \ket{1} &\mapsto \frac{1}{\sqrt{2}}\left(\ket{0} - \ket{1}\right)
            \end{align*}
            These states appear frequently and so it is common to give them their own notation.
            We define
            \[
                \ket{+} := \frac{1}{\sqrt{2}}\left(\ket{0} + \ket{1}\right)
            \]
            and
            \[
                \ket{-} := \frac{1}{\sqrt{2}}\left(\ket{0} - \ket{1}\right)
            \]

            The Hadamard gate has matrix representation
            \[
                H := \frac{1}{\sqrt{2}} \rmat{1}{1}{1}{-1}
            \]
        \end{example}

        
\subsection{Quantum Circuits}
        
        Much like in classical computation, it is convenient to represent manipulations of qubits as circuits.
        A \emph{quantum circuit} is made up of qubits, wires, and gates. It is perhaps easiest to define by giving 
        examples. 

        Consider the following very simple circuit
        \[\Qcircuit @C=1.5em @R=.7em {
                \lstick{\ket{0}} & \qw & \gate{X} & \gate{H} & \qw & \qw & \ket{-}
        }\]

        This circuit depicts a single qubit starting in state $\ket{0}$. As it travels through the wire left to 
        right, $X$ takes it to $\ket{1}$ and then $H$ takes $\ket{1}$ to $\ket{-}$. This circuit represents the 
        equation
        \[
            \ket{-} =  HX \ket{0}       
        \]
        Of course by associativity, we could have used a single gate $HX$.
        
        We allow for one special gate that is not unitary to denote measurement. The measurement gate is depicted 
        \[
            \Qcircuit @C=1em @R=.7em {
               & \qw & \meter &  }\]


\subsection{Multiple qubits} 

        Up until this point we have only considered single-qubit systems. However, computation is not very 
        interesting if we're only restricted to a single qubit. 

        Consider a string of two bits. This string has four possible values: 00, 01, 10, 11. Much like in the 
        single bit case, while a string of two bits has four possible states, a string of two qubits has four basis 
        states. Keeping with the analogy to bits from before, we number these basis vectors in binary and call them 
        $ \ket{00}, \ket{01}, \ket{10}, \ket{11}$ which represent $(1,0,0,0), (0,1,0,0), (0,0,1,0),$ and 
        $(0,0,0,1)$ respectively.
        
        Formally, the state space of two qubits is given by $\C^2 \otimes \C^2$, where $\otimes$  denotes the 
        \emph{tensor product}  of two vector spaces. If $\psi$ and $\varphi$ are two qubits with states 
        $\ket{\psi}$ and $\ket{\varphi}$ respectively, then we denote their combined state $\ket{\psi}\ket\varphi 
        := \ket{\psi} \otimes \ket{\varphi}$. It is also common to write $\ket{\psi\varphi}$.

        \begin{definition}
            Let $V$ and $W$ be vector spaces with bases $\{v_1,...v_n\}$ and $\{w_1, ...w_m\}$ respectively.
            Let $B$ be the set of all formal pairs $v_i \otimes w_j$ (read $v_i$ tensor $v_j$) for each $1 \leq i 
            \leq n$ and $1 \leq j \leq m$.

            The \emph{tensor product space} $V \otimes W$ is defined to be the vector space spanned by the basis 
        $B$.  \end{definition}
        
        The tensor product is a complicated construction and defining it in full generality here would take us 
        beyond the scope of this thesis. Luckily, all of the spaces we are working with are finite and we have 
        already chosen bases, so we don't need to worry about this. For the purposes of quantum computing this 
        definition is sufficient. 

        In general, the combined state space of two quantum systems is given by their tensor product. The state 
        space of an $n$-qubit system is $(\C^2)^{\otimes n} = \C^2 \otimes \C^2 ... \otimes \C^2$ ($n$ times). A 
        useful way to think about this is that the tensor product combines the two states without adding any 
        relationship between the 2 qubits.

        This construction naturally allows us to extend our circuit diagrams to multiple qubits. Consider the 
        following two qubit circuit
            \[\Qcircuit @C=1em @R=.7em {
                    \lstick{\ket{0}} & \qw & \gate{H} & \qw & \qw &  \\
                    \lstick{\ket{0}} & \qw & \gate{X}  & \qw & \qw & }
            \]
        This circuit starts in state $\ket{00}.$ The first qubit gets mapped by the Hadamard to $\ket{+}$ and the 
        second qubit is mapped by the $X$ gate to $\ket{1}$. Thus it returns $\ket{+}\ket{1}$. Algebraically, this 
        expresses the equation
        \[
            (H \otimes X)(\ket{00}) = \ket{+}\ket{1}
        \]
        This example could have really just been two single qubit circuits. The two wires run entirely in parallel 
        here. However, most quantum circuits are not like this. Most of the two qubit gates cannot be split up as a 
        product of single qubit gates.

        Consider the \texttt{Controlled-NOT} gate defined as
        \[
            \Qcircuit @C=1.4em @R=1.2em { \lstick{\ket{x}}  & \ctrl{1} &  \qw \quad \ \  \ \ket{x} \\
                \lstick{\ket{y}}  & \targ{0} &  \qw \quad \quad \quad \quad \ket{x \oplus y} &
        }\]
        It has the following action on the standard basis: If the top wire is $\ket{0}$, then the bottom wire is 
        unchanged.  If the top wire is a $\ket{1}$, then it acts as a not gate on the bottom wire. Thus it has 
        matrix representation \[
            \texttt{CNOT} :=
             \begin{bmatrix}
                1 & 0 & 0 & 0 \\
                0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1 \\
                0 & 0 & 1 & 0
              \end{bmatrix}
         \]
         As an example consider the circuit
        \[\Qcircuit @C=1.4em @R=1.2em {
                \lstick{\ket{0}}  & \gate{H} & \ctrl{1} &  \qw \quad \ \  \ \ket{x} \\
                \lstick{\ket{0}}  & \qw & \targ{0} &  \qw \quad \quad \quad \quad {\ket{x \oplus y}}
        }\]
        This circuit starts in state $\ket{00}$. The first timestep applies a Hadamard to the top wire and the 
        identity to the bottom wire, thus it changes the state to $\ket{+}\ket{0}$. To compute the action of the 
        \texttt{Controlled-NOT} notice that
        \[
            \ket{+}\ket{0} = \frac{1}{\sqrt{2}}\bigl(\ket{0} + \ket{1}\bigr)\ket{0}= 
            \frac{1}{\sqrt{2}}\bigl(\ket{0}\ket{0}+\ket{1}\ket{0}\bigr) = 
            \frac{1}{\sqrt{2}}\bigl(\ket{00}+\ket{10}\bigr)
        \]
        Thus,
        \[
            \texttt{CNOT} \ket{+}\ket{0} = \texttt{CNOT}\frac{1}{\sqrt{2}}\bigl(\ket{00}+\ket{10}\bigr) =
            \frac{1}{\sqrt{2}}\bigl(\ket{00} + \ket{11}\bigr)
        \]

        Therefore this circuit sends $\ket{0}\ket{0}$ to $\frac{1}{\sqrt{2}}\bigl(\ket{00} + \ket{11}\bigr)$.


        This state is an example of another important property of quantum systems that cannot be seen with only one 
        qubit. It is what is referred to as an \emph{entangled state} meaning that it has no representation as the 
        product of single qubit states.
        
        \subsection{Quantum Oracles}
        The majority of the problems in quantum computing will be phrased as oracle problems. The motivation for 
        this is that oracle problems are easy to express and of importance classically, yet extend very naturally 
        to analogous problems in the quantum setting. 

        The way that we give circuits for oracle problems is by adding an extra black-box gate to our collection.  
        The issue here is that the black-box functions in most oracle problems are not unitary and thus not 
        realizable on a quantum computer. The way to fix this, is to encode the oracle function $f$ as a unitary 
        matrix in a fashion similar to the \texttt{Controlled-NOT} gate.

        Given a function $f : \{0, 1\}^n \rightarrow \{0, 1\}^m$, let $U_f : (\C^2)^{\otimes n} \bigotimes (\C^2)^{ 
        \otimes m} \rightarrow (\C^2)^{\otimes n}\bigotimes (\C^2)^{\otimes m}$ be the unitary map defined by
        \[
            \ket{x}\otimes \ket{y} \mapsto \ket{x} \otimes \ket{f(x) \oplus y}
        \]
        In a circuit we write this as 
        
        \[\Qcircuit @C=1em @R=1.3em {
                \lstick{\ket{x}}  & \multigate{1}{U_f} & \qw & \ket{x} \\
        \lstick{\ket{y}} & \ghost{U_f} & \qw & \quad \quad \ \quad\ket{y \oplus f(x)} }\]
        
        In this context, the wires labeled $\ket{x}$ and $\ket{y}$ represent the states of potentially multiple 
        qubits and are referred to as \emph{registers}. We refer to the register that is fixed by the oracle as the 
        \emph{query register} and the other as the \emph{response register}.
        

        
        \subsection{Deutsch's Algorithm}
        First, let's revisit the problem given in the beginning this chapter in Example 1. Recall we had the 
        following problem:
        
        \begin{problem} Given oracle access to a function $f: \{0,1\} \rightarrow \{0, 1\}$. What is the minimum 
            number of
            queries required to determine $f(0) \oplus f(1)$ where $\oplus$ denotes addition mod 2?
        \end{problem}
        
        Consider the following circuit
        \[\Qcircuit @C=1em @R=1.3em {
                \lstick{\ket{0}}  & \qw & \gate{H} & \multigate{1}{U_f} & \gate{H} & \qw & \meter \\
        \lstick{\ket{0}} & \gate{X} & \gate{H} & \ghost{U_f} &  \qw & \qw &\qw  }\]
        
        The circuit starts in state $\ket{00}$, then the $X$ gate on the bottom wire takes it to $\ket{01}$. The 
        two Hadamard gates take $\ket{01}$ to $\ket{+}\ket{-}$. We rewrite this state in the standard basis
        \[
            \ket{+}\ket{-} = \frac{1}{2}\bigl(\ket{0} + \ket{1}\bigr)\bigl(\ket{0} - \ket{1}\bigr) = 
            \frac{1}{2}\bigl(\ket{00} - \ket{01} + \ket{10} - \ket{11}\bigr)
        \]
        \begin{align*}
            U_f\bigl(\ket{+}\ket{-}\bigr) &= \frac{1}{2} U_f\bigl(\ket{00} - \ket{01} + \ket{10} - \ket{11}\bigr) 
            \\
                                          &= \frac{1}{2} \bigl( U_f\ket{00} - U_f\ket{01} + U_f\ket{10} - 
                                          U_f\ket{11} \bigr) \\
                                          &= \frac{1}{2}\bigl( \ket{0}\ket{0 \oplus f(1)} - \ket{0}\ket{1 \oplus 
                                          f(0)} + \ket{1}\ket{0 \oplus f(1)} - \ket{1}\ket{1 \oplus f(1)}\bigr) \\
        \end{align*}

        Now applying the Hadamard to the top gate takes this state to

        \begin{align*}
            \frac{1}{2}\bigl( \ket{+}\ket{0 \oplus f(1)} - \ket{+}\ket{1 \oplus f(0)} + \ket{-}\ket{0 \oplus f(1)} 
        - \ket{-}\ket{1 \oplus f(1)}\bigr)
        \end{align*}
       which expands to
       \[
           \frac{1}{4}\big[ \ket{0}\ket{0 \oplus f(1)} + \ket{1}\ket{0 \oplus f(1)} + ... - \ket{0}\ket{1 \oplus 
           f(1)} + \ket{1}\ket{1 \oplus f(1)} \big]
       \]
       If $f(0) \neq f(1)$, then $\ket{0}\ket{0 \oplus f(1)} = \ket{0}\ket{1 \oplus f(1)}$ and so those will cancel 
       in the above sum. Writing this out for all the states, one obtains that the first qubit is $\ket{1}$ if and 
       only if $f(0) = f(1)$.

        
    %\subsubsection{The Bernstein-Vazirani Algorithm}


            %\begin{problem}
                %Let $s \in \{0, 1\}^m$ be a hidden $m$-bit binary string and let $b \in \{0, 1\}$ be a hidden bit.  
                %Given oracle access to a function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ defined by
                %$f(\vec{x}) = \vec{x} \cdot \vec{s} + b \ (\text{mod } 2)$, how many queries are required to determine 
                %the values of $\vec{s}$ and $b$?
            %\end{problem}

        %The trick to this problem is to utilize a technique sometimes referred to as \emph{Fourier sampling}.

        
        %Note that writing $\ket{+}^{\otimes n}$ in the standard basis yields
        %\[
            %\ket{+}^{\otimes n} = \frac{1}{\sqrt{2^n}}\left( \ket{0} + \ket{1} \right)^{\otimes n} = 
            %\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n} \ket{x}
        %\]
        %Where $\{0,1\}^n$ is the set of all $n$ length binary strings. Thus one can think of the state 
        %$\ket{+}^{\otimes n}$ as the generalization of the $\ket{+}$ state to multiple qubits. It is an evenly 
        %weighted sum of each of the qubits corresponding to length $n$ binary strings. 
        

        

            %Define a circuit with state space $\C^{\otimes 2n} \otimes \C^2$. We initialize the system by setting 
            %the first $n$ qubits to $\ket{1}$ and the response qubit to $\ket{0}$.
        
        
            
            %\[
                %\Qcircuit @C=1em @R=1em {
               %\lstick{\ket{1}} & \qw &
                     %\gate{H} & \qw &
                     %\multigate{3}{U_f} & \qw &
                    %\gate{H} & \qw &
                    %\meter 
                    %\\
                %\lstick{\ket{1}} & \qw &
                    %\gate{H} & \qw &
                    %\ghost{U_f} & \qw &
                    %\gate{H} & \qw &
                    %\meter 
                      %\\
                %\lstick{\ket{1}} & \qw &
                    %\gate{H} & \qw &
                    %\ghost{U_f} & \qw &
                    %\gate{H} & \qw &
                    %\meter 
                      %\\
                    %\lstick{\ket{0}} &  \qw &
                     %\qw &
                     %\qw &
                     %\ghost{U_f} &
                     %\qw &  \qw &
                 %\qw \qw \qw & \qw \qw &}
           %\]
           


        
