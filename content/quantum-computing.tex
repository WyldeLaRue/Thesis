\chapter{Quantum Computing}

\section{Learning Problems}

\subsection{A Motivating Example}


        Suppose you're involved in a simple card game: A dealer places two cards\footnote{Assume that the cards are
        either red or black, with equal probability of each occurring}  face down on a table. You win the game and a
        substantial prize if you can guess whether the two face-down cards share the same color. You're allowed to
        ask the dealer to reveal cards to you, but for each card revealed your potential prize gets smaller.

        How many of the cards do you need to see to determine with certainty whether the cards share the same
        color?  Maybe you don't need to know for certain. How does the probability of you being able to guess the
        correct answer relate to the number of cards seen?


        If you have no information at all, you can't do substantially better (or worse) than a fifty-percent
        chance. In fact, seeing only a single card, does not give you any more knowledge of what the answer to the
        question is. If you wanted to know with certainty what the answer was, you would need to see both cards.


        This is of course a very simple game, but it is an example of a type of problem that we refer to as
        \emph{learning problems} or often \emph{oracle problems}. These problems consist of a learner who is trying
        to determine the answer to some question, generally to find the output of a certain function. The learner
        starts out with incomplete information, but is given access to an \emph{oracle function} she can query to
        gain more information. An oracle function--also sometimes called a black-box function--is one that you can
        evaluate the oracle at any input of your choosing, but you have no information about the function other
        than its responses to your inputs. The learner's goal is to determine the answer to the question in as few
        questions as possible. 

        We rephrase the scenario given above in this language.  Choose 0 to represent a black card and 1 to
        represent a red card. Suppose the two facedown cards are labeled $a$ and $b$.   
       
        \begin{example} 
            Given oracle access to a function $f: \{a, b\} \rightarrow \{0, 1\}$. What is the minimum number of
            queries required to determine $f(a) \oplus f(b)$ where $\oplus$ denotes addition mod 2?
        \end{example}

        
        \TODO{rewrite this example}

        Phrasing problems in terms of oracles is an extremely useful tool. It provides an approach for using 
        information theoretic arguments to provide algorithmic lower bounds. We know of very few tools to show that 
        there is no way to possible solve something quickly.

        \begin{example}
            \TODO{Example 2?} 
        \end{example}


        

\section{Classical Computing}
        \subsection{History, Bits, Information Theory}
        Before we delve into  \emph{quantum computation}, we first briefly give an overview of the relevant 
        concepts from the study of \emph{classical} computation. Although we will not need information theory for 
        any of the arguments we will make, it will be used frequently as a source of intuition.

        The fundamental idea of information theory is that any the amount of information that an object contains is 
        related to the number of possible states it could have been in. In this way, the bit, which can be in 
        exactly one of two possible states is the most basic unit of information.


        In the 16th and 18th centuries mathematicians and logicians worked to convert formal systems of logic into 
        algebra and arithmetic. One of the most prominent successes of these attempts was by George Boole who 
        managed to faithfully encode propositional logic in the language of arithmetic and algebra. The idea was to 
        let 1 and 0 represent true and false respectively. Then, by interpreting addition and multiplication as mod 
        2, one obtains exactly the logical operations \texttt{AND} and  \texttt{XOR}. In modern terms, we recognize 
        this as the structure of the field $\F_2$. \TODO{remove this paragraph}
        
        \TODO{\textit{These next two paragraphs just repeat the previous two paragraphs, clean this up}}

        We define a bit as an element of $\Z/2\Z = \{0,1\}$. It also can be useful to think of bits as representing 
        a true or false value. This relationship gives a direct correspondence between classical computation and 
        propositional logic. We write the state space of a bit as $\Z/2\Z$ to emphasize that it has a natural 
        additive operation given by mod 2 addition.  Alluding to propositional logic, this operation is called 
        exclusive-or, usually written as \texttt{XOR} or $\oplus$, although we will oftentimes just write $+$.

        Of course having just one bit, is not particularly interesting. As a reference, it is common today to 
        measure memory in terms of \emph{gigabytes}. One gigabyte is equivalent to eight billion bits. We most 
        often work with \emph{strings of bits}. A string of 2 bits has four possible states, each described by an 
        element of $\Z/2\Z \times \Z/2\Z$. Analogously, an $n$ bit string has state space $(\Z/2\Z)^n$. The group 
        addition readily extends to $n$ bit strings giving it the operation that is commonly known as bitwise XOR.


        Thus any function $f :  \{0, 1\}^m \rightarrow \{0, 1\}^n$ can be expressed by some sequence of logical 
        operations and each sequence of logical operations corresponds to a function. 
        
        \subsection{Circuits and Logic Gates}

        \begin{definition}
            [Nielsen and Chuang, pg 129]
            A \emph{circuit} is made up of wires and gates, which carry information around, and perform simple 
            computational tasks, respectively.
        \end{definition}

        \begin{definition}
            [Nielsen and Chuang, pg 129]
            A \emph{logic gate} is a function $f : \{0, 1\}^k \rightarrow \{0, 1\}^\ell$ from some fixed number $k$ 
            of input bits to some fixed number $\ell$ of output bits.
        \end{definition}

        \begin{example}
         Here is an example of a logic gate

         \begin{figure}[ht]
            \centering
            \placeholderfig
            \caption{ The logic gates \texttt{AND} and \texttt{XOR} }
        \end{figure}
        \end{example}

        \bigskip

        \begin{example}
            Here is an example of a circuit

            \begin{figure}[ht]
                \centering
                    \placeholderfig
                \caption{An example of a basic circuit, maybe make it match whatever example I use for a circuit 
                family}
            \end{figure}

    
        \end{example}

        We state the following important result without proof.
        \begin{theorem}
            The set of gates $\{ \texttt{AND},\ \texttt{NOT},\ \texttt{OR} \}$ are \emph{universal}. That is any 
            function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ can be represented by circuit a consisting of only 
            \texttt{AND}, \texttt{NOT}, and \texttt{OR} gates.
        \end{theorem}
        
        %{\textcolor{red}{\bfseries I don't know how to fill the rest of this circuit part in}}
        

        \subsection{Circuits as Algorithms}
        
        \begin{definition}
            [verbatim from Sipser -- cleanup]
                 A \emph{circuit family} is an infinite list of circuits $(C_0, C_1, C_2, ...)$, where $C_n$ has 
                 $n$ input bits.
        \end{definition}

        \begin{definition}
            The circuit complexity of a function is the size complexity of a minimal circuit family for that 
            language. 
        \end{definition}

        \begin{example}
            Example circuit family to compute something. Maybe how many input bits are odd.  
            \begin{figure}[ht]
                \centering
                    \placeholderfig
                \caption{}
            \end{figure}
        \end{example}
        
        \subsection{Introduce controlled gate notation}
        
        Just example of Toffoli gate or whatever

        \subsection{Circuits with Oracles}

        We can consider circuits with oracle access.  Give example from original motivating problem.



\section{Quantum Computing}
        Now we introduce the concepts required for quantum computation. In the quantum world, the \emph{qubit} is 
        the fundamental unit of information. In the same way that we could express any classical algorithm as a 
        circuit of logical operations on bits, we can express any quantum operation as a sequence of \emph{unitary} 
        operations on \emph{qubits}.
       
   \subsection{Qubits}

        The following definitions will give a complete description of a model of quantum computing. These can all 
        be derived from the postulates of quantum mechanics.
        
        Whereas the state of a bit has \emph{two} possible values---either 0 or 1---the state of a qubit is a unit
        vector in complex vector space spanned by \emph{two} basis states. We give the following precise definition

        Whereas a bit has two states---0 or 1---a qubit has \emph{two basis states}. The following definition makes 
        this precise
        \begin{definition}
            The state of a \emph{qubit} is a unit vector in $\C^2$. That is, a pair of complex numbers
            \[
                (\alpha, \beta) \in \C^2
            \]
            satisfying the normalization condition %
            \[
                |\alpha|^2 + |\beta|^2 = 1
            \]
        \end{definition}
        
        We refer to the space $\C^2$ as the \emph{state space} of a qubit and consider it to be an inner product 
        space equipped with the standard inner product on $\C^n$.\footnote{In quantum mechanics literature, state 
            spaces of quantum systems are always referred to as \emph{Hilbert spaces} regardless of their 
            dimension. This can be confusing as \emph{Hilbert spaces} in mathematics are generally associated with 
        infinite dimensional spaces. Since all of the spaces in this thesis will be finite dimensional (and 
    isomorphic to $\C^{2^n}$), it is easier to avoid the confusion and use the term state space instead.}
    We choose the standard basis $\{(0,1), (1,0)\}$ to represent $\C$. In order to make the analogy with bits more 
    clear, we denote \[
            \ket{0} := \rvec{1}{0}, \quad
            \ket{1} := \rvec{0}{1}.
         \] The symbol $\ket{\ }$ is called a \emph{ket} and is used to denote a vector representing a quantum 
         state. It comes from the \emph{bra-ket} notation which is widely used in the greater theory of quantum 
         mechanics.
        
        
         \subsection{Measurement} 
         
         Although a qubit has a quantum state in $\C^2$, the we cannot directly observe this quantum state. Despite 
         having what seems like a much richer state, when we try to measure qubits using any sort of detector, they 
         snap into the states $\ket{0}$ or $\ket{1}$. This of course defies any reasonable expectations one would 
         have about the world, and has raised much philosophical debate about how it should be interpreted. 
         However, regardless of what interpretation we take, it remains an experimental fact. The following 
         postulate formalizes this concept as a process called \emph{measurement in the computational basis} .

         \begin{postulate}
             Given a qubit $\psi$, we may perform \emph{measurement} of $\psi$ in the \emph{computational basis}. 
             If $\psi$ was in state $\alpha \ket{0} + \beta \ket{1}$ prior to the measurement, after the 
             measurement it will be in state $\ket{0}$ with probability $|\alpha|^2$ and $ \ket{1}$ with 
             probability $|\beta|^2.$
     \end{postulate}

        This is only a specific case of a much more general postulate of measurement in quantum mechanics. However, 
        this conception of measurement will be sufficient enough for many of the results in quantum computing and 
        all of the results that we will need to consider. A more in depth discussion of the postulates of quantum 
        mechanics and how they relate to quantum computing can be found in \cite{Nielsen&Chuang}.
        
        If we naively think of the state of a qubit as being in $\R^2$ rather than $\C^2$ by just ignoring the 
        imaginary part, we can generate some limited geometric intuition about what is going on.


        \begin{figure}[ht]
            \centering
            \begin{center}
            \begin{tikzpicture}
                 \draw[->] (0,0) -- (0,4) node[above]{$\ket{1}$};
                 \draw[->] (0,0) -- (4,0) node[right]{$\ket{0}$};
                 \draw[->, thick] (0,0) -- (2, 3.4) node[right]{$\frac{\sqrt{3}}{2}\ket{1} + \frac{1}{2}\ket{0}$};
            \end{tikzpicture}
            \end{center}
            \caption{A qubit with state $\frac{\sqrt{3}}{2}\ket{1} + \frac{1}{2}\ket{0}$ pictured in the plane by 
            ignoring the imaginary part. }
    \end{figure}

    A measurement on the pictured qubit will return 0 with probability $3/4$ and $1$ with probability $1/4$. This 
    perspective hopefully makes it clear why the state of a qubit had to be a unit vector. When written in the 
    standard basis, the coefficients of $\ket{0}$ and $\ket{1}$ correspond to the probability of a measurement 
    producing that outcome. Thus requiring that this state be a unit vector is equivalent to requiring that the 
    total probabilities sum to one.


    This also motivates the other postulate of quantum mechanics that we will need to formalize this model of 
    quantum computation. 

    \begin{postulate}
        The valid operations on quantum states are those given by \emph{unitary transformations}.
    \end{postulate}

    The unitary transformations on $\C^n$ are exactly the \emph{isometries} of $\C^n$, that is, the ones that 
    preserve the inner-product. This is, perhaps not too surprising, given that preserving the metric is necessary 
    condition to ensure that the probabilities sum to one. 

    \begin{definition}
        The set of unitary transformations on $\C^n$ can be represented as the set of $n \times n$ matrices $U$ 
        satisfying the identity $U^{-1} = U^\dagger$ where $U^\dagger$ denotes the conjugate-transpose of $U$.
    \end{definition}

    A consequence of this postulate of quantum mechanics is that quantum information cannot be destroyed without a 
    making a measurement.

    
    
\subsection{Gates}
        
        By postulate 2, the valid operations on a qubit are the $2 \times 2$ unitary matrices.
        

        This part of quantum computing can be confusing at first, since the notation constantly switches between 
        kets and matrices.

        \begin{example}
            The quantum \texttt{NOT} gate is the single qubit gate defined by
            \begin{align*}
                \ket{0} &\mapsto \ket{1} \\
                \ket{1} &\mapsto \ket{0}
            \end{align*}
            It should be noted that it is common to refer to the quantum \texttt{NOT} gate by the letter $X$.

            In standard vector notation this is
            \begin{align*}
                \rvec{1}{0} &\mapsto \rvec{0}{1} \\
                \rvec{0}{1} &\mapsto \rvec{1}{0} 
            \end{align*}

            Which gives us that the quantum \texttt{NOT} gate is represented by the matrix
            \[
                X := \rmat{0}{1}{1}{0}
            \]
        \end{example}

        
        \begin{example}
            A very important single qubit gate is the \emph{Hadamard} gate. The Hadamard gate, denoted $H$, can be 
            defined in terms of its action on the standard basis as
            \begin{align*}
                \ket{0} &\mapsto \frac{1}{\sqrt{2}}\left(\ket{0} + \ket{1}\right) \\
                \ket{1} &\mapsto \frac{1}{\sqrt{2}}\left(\ket{0} - \ket{1}\right)
            \end{align*}
            These states appear frequently and so it is common to give them their own notation.
            We define
            \[
                \ket{+} := \frac{1}{\sqrt{2}}\left(\ket{0} + \ket{1}\right)
            \]
            and
            \[
                \ket{-} := \frac{1}{\sqrt{2}}\left(\ket{0} - \ket{1}\right)
            \]

            The Hadamard gate has matrix representation
            \[
                H := \frac{1}{\sqrt{2}} \rmat{1}{1}{1}{-1}
            \]
        \end{example}

        
\subsection{Quantum Circuits}
        
        Much like in classical computation, it is convenient to represent manipulations of qubits as circuits.
        A \emph{quantum circuit} is made up of qubits, wires, and gates. It is perhaps easiest to define by giving 
        examples. 

        Consider the following very simple circuit
        \[\Qcircuit @C=1.5em @R=.7em {
                \lstick{\ket{0}} & \qw & \gate{X} & \gate{H} & \qw & \qw & \ket{-}
        }\]

        This circuit depicts a single qubit starting in state $\ket{0}$. As it travels through the wire left to 
        right, $X$ takes it to $\ket{1}$ and then $H$ takes $\ket{1}$ to $\ket{-}$. This circuit represents the 
        equation
        \[
            \ket{-} =  HX \ket{0}       
        \]
        Of course by associativity, we could have used a single gate $HX$.
        
        We allow for one special gate that is not unitary to denote measurement. The measurement gate is depicted 
        \[
            \Qcircuit @C=1em @R=.7em {
               & \qw & \meter & \cw 
       }\]
        The two parallel lines indicate that the wire is carrying classical information.


\subsection{Multiple qubits} 

        Up until this point we have only considered single-qubit systems. However, computation is not very 
        interesting if we're only restricted to a single qubit. 

        Consider a string of two bits. This string has four possible values: 00, 01, 10, 11. Much like in the 
        single bit case, while a string of two bits has four possible states, a string of two qubits has four basis 
        states. Keeping with the analogy from before, we number these basis vectors in binary and call them $ 
        \ket{00}, \ket{01}, \ket{10}, \ket{11}$ which represent $(1,0,0,0), (0,1,0,0), (0,0,1,0),$ and $(0,0,0,1)$ 
        respectively.

        Formally, we think of the state space of a pair of qubits as being $\C^2 \otimes \C^2$, where $\otimes$ 
        denotes the tensor product of two vector spaces. The tensor product is a complicated construction and 
        defining it in full generality here would take us beyond the scope of this thesis. Luckily, all of the 
        spaces we are working with are finite and we have already chosen bases, so we don't need to worry about 
        this. For the purposes of quantum computing the following definition is sufficient.

        \begin{definition}
            Let $V$ and $W$ be vector spaces with bases $\{v_1,...v_n\}$ and $\{w_1, ...w_m\}$ respectively.
            Define $B$ to be the set of all formal pairs $v_i \otimes w_j$. 

            The tensor product $V \otimes W$ is given by $\span B$.
        \end{definition}

        In general the state space of an $n$-qubit system is $\C^{\otimes 2n}$.


        
 
We can have circuits with multiple qubits

        \[\Qcircuit @C=1em @R=.7em {
                \lstick{\ket{0}} & \qw & \gate{H} & \qw & \qw & \ket{+}\\
        \lstick{\ket{0}} & \gate{Z} & \gate{H} & \qw & \qw & \ket{-}
        }\]
        
        

        Let \begin{example}
            Deutsch-Josza
            $$
            \Qcircuit @C=1em @R=.7em {
                & \gate{H} & \gate{Z} & \gate{H} & \qw \\
                & \qw & \gate{X} & \qw & \qw
            }
            $$
        \end{example}

        The Deutsch-Josza Algorithm 
    
            \subsection{The Bernstein-Vazirani Algorithm}
            
            \begin{problem}
                Let $s \in \{0, 1\}^m$ be a hidden $m$-bit binary string and let $b \in \{0, 1\}$ be a hidden bit.  
                Given oracle access to a function $f : \{0, 1\}^n \rightarrow \{0, 1\}$ defined by
                $f(\vec{x}) = \vec{x} \cdot \vec{s} + b \ (\text{mod } 2)$, how many queries are required to determine 
                the values of $\vec{s}$ and $b$?
            \end{problem}

            \textbf{The Bernstein Vazirani Algorithm}

            
            Define a circuit with state space $\C^{\otimes 2n} \otimes \C^2$. We initialize the system by setting 
            the first $n$ qubits to $\ket{1}$ and the response qubit to $\ket{0}$.

            The key to this problem will be to utilize a technique sometimes known as the \emph{phase-kickback 
            trick}. 
            
            
            \[
                \Qcircuit @C=1em @R=1em {
               \lstick{\ket{1}} & \qw &
               \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6.3em>&
                     \gate{H} & \qw &
                     \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6.5em>&
                    \ctrl{1} & \qw &
                    \qw \ar@{.}[]+<-0em,1em>;[d]+<-0em,-6em>&
                    \gate{H} & \qw &
                    \meter 
                    \\
                \lstick{\ket{1}} & \qw &\qw &
                    \gate{H} & \qw &\qw &
                    \ctrl{1} & \qw &\qw &
                    \gate{H} & \qw &
                    \meter 
                      \\
                \lstick{\ket{1}} & \qw &\qw &
                    \gate{H} & \qw &\qw &
                    \ctrl{1} & \qw &\qw &
                    \gate{H} & \qw &
                    \meter 
                      \\
                 \frac{1}{\sqrt{2}} &  \qw &\qw &
                     \qw &\qw &
                     \qw &                
                     \gate{U} & \qw &
                     \qw &  \qw &
                     \qw \frac{1}{\sqrt{2}} \\
               && 0 &  &  & 1 &  &  &2  & &
            }
           \]
           


        
